import inspect
import json
from argparse import ArgumentParser

import pytorch_lightning as pl
import torch as th
from pytorch_lightning.utilities import parsing
from torch.utils.data import Dataset


class BaseDataset(Dataset):

    def __init__(self, input, labels=None, max_len=256) -> None:
        super().__init__()

        # If filepath is true, then implement a parsing function to get self.input & self.labels
        self.input, self.labels = input, labels
        self.max_len = max_len

        self._tokenizer = None

    def __getitem__(self, index):
        text, target = self.input[index], self.labels[index]

        # Replace this with a more generic tokenizer/ability to change any tokenization params
        self.encoding = self._tokenizer.encode_plus(
            text,
            add_special_tokens=True,
            max_length=self.max_len,
            return_token_type_ids=False,
            padding='max_length',
            truncation=True,
            return_attention_mask=True,
            return_tensors='pt',
        )

        return \
            self.encoding.input_ids.squeeze(), \
            self.encoding.attention_mask.squeeze(), \
            th.tensor(target, dtype=th.long)


class BaseDataModule(pl.LightningDataModule):

    @classmethod
    def add_argparse_args(cls, parent_parser: ArgumentParser) -> ArgumentParser:
        r"""Extends existing argparse by default `LightningDataModule` attributes.
                """
        parser = ArgumentParser(parents=[parent_parser], add_help=False)
        added_args = [x.dest for x in parser._actions]

        blacklist = ["kwargs"]
        depr_arg_names = blacklist + added_args
        depr_arg_names = set(depr_arg_names)

        allowed_types = (str, int, float, bool, dict)

        for arg, arg_types, arg_default in (
            at
            for at in cls.get_init_arguments_and_types()
            if at[0] not in depr_arg_names
        ):
            arg_types = [at for at in arg_types if (
                at in allowed_types) or isinstance(at, str)]
            if not arg_types:
                # skip argument with not supported type
                continue

            arg_kwargs = {}
            arg_choices = None
            if dict in arg_types:
                use_type = json.loads
            elif bool in arg_types:
                arg_kwargs.update(nargs="?", const=True)
                # if the only arg type is bool
                if len(arg_types) == 1:
                    use_type = parsing.str_to_bool
                # if only two args (str, bool)
                elif len(arg_types) == 2 and set(arg_types) == {str, bool}:
                    use_type = parsing.str_to_bool_or_str
                else:
                    # filter out the bool as we need to use more general
                    use_type = [at for at in arg_types if at is not bool][0]
            elif all(isinstance(at, str) for at in arg_types):
                use_type = str
                arg_choices = arg_types
            else:
                use_type = arg_types[0]

            if arg_default == inspect._empty:
                arg_default = None

            parser.add_argument(
                f"--{arg}",
                dest=arg,
                default=arg_default,
                # required=True if not arg_default else False,
                type=use_type,
                choices=arg_choices,
                help=f"autogenerated by plb.{cls.__name__}",
                **arg_kwargs,
            )

        return parser
